# 小本本

- 完全二叉树一定有一个子树是满二叉树
- 动规问题中，对dp数组的定义，可以直接用字典而非[]，因为可以无限制的使用`dp[i]`而不需要提前定义长度
- 层序遍历中`while queue:`内的`len(queue)`只能用于内部迭代该层的遍历，不可用于判断深度。
- 单向BFS解决的问题，若终点位置明确，可以考虑用双向BFS，使用两个HashSet代替queue，两个方向遍历，随时交换，看是否有交集即可。
- 二分查找问题不要上来直接写，先搞定普通查索引的问题，再说明这种算法的局限性，是否需要进一步求左边界、右边界。
- python字符串列表`strs = List[str]`小技巧：`max(strs)`, `min(strs)` 分别表示字典序最大和字典序最小的字符串。
- 数组内nSum问题等需要排重，记得用好`for`循环配合 `continue`功能，判断指针移动值未移动后直接再次循环即可；或者直接用`while`循环移动指针到下一个不同值处。
- 二叉树问题：两个节点都为空：`if not (left or right):`；两个节点至少一个为空：`if not (left and right):`；然后才可以通过`if left.val != right.val:`判断后续对称性等问题。
- 二叉树的递归操作内，只要想`node.left`/`node.right`/`node.val`之前都必须先判断`if not node`否则必报错。
- python中的普通list数组可以使用拉链函数 `(zip(*matrix))` 进行转置。
- 判断二叉树叶子节点：1、`if not node.left and not node.right`；2、`if not  (node.left or node.right)`。
- python 检测字符串s是否由字母和数字组成：`s.isalnum()`，`s.isdigit()`，`s.isnumeric()`。但注意带符号的不能识别，卧槽这么重要的小技巧以前居然从来没见过？
- 众数问题、多数元素、最多出现问题莫忘了考虑使用**摩尔投票**法。
- 涉及到偶数个元素中找出现一次的某个元素，考虑使用 `^`运算，异或可交换，任何数异或自己都为零，零异或任何数都是任何数。
- 接上，若是在奇数各元素中找到出现一次的某个元素，同样使用异或 `^` 运算，只是多加几个中间变量就好，每次异或遍历时让其他的中间变量取非后求和运算即可，`once = ~twice & ~third & (num ^ once)`。
- 构建多为空数组时，不要小聪明用 `[[0] * n] * n`，会有浅拷贝问题，死都不知道怎么死的，老老实实`[[0 for _ in range(n)] for _ in range(n)]`。
- 十进制->二进制：`bin(42) ->'0b101010' `；二进制-> 十进制：`eval('0b101010') -> 42`。
- 双变量同时赋值更新时，如果不想使用临时变量，不要要写在一行内同时赋值。
- 二维的DP初始化的时候无比无比仔细，读取时先写的左边后构建，如`dp[i][j], 0 <= i <= m, 0 <= j <= n`，则构建时：`dp = [[0 for _ in range(n)] for _ in range(m)]`。一定是反着来的，写完要测试检查一下，不要小聪明用生成式。
- 整除取整问题：向下取整直接`m // n`；若想向上取整，巧妙方法`(m + n - 1) // n`。太特么骚了！
- python的取整函数再复习：向上取整`math.ceil()`；向下取整`math.floor()`。
- 遇到回溯问题，实在没思路了可以直接调用`itertools.permutations`模块，可以直接输出全排列结果，`permutations("abc", 3)`
- 跑快慢指针之前一定要注意先判定`if not head nor not head.next: return head`，只有先保证不止一个节点之后才有快慢跑起来的意义。
- 归并排序更适用于链表的排序，top-down的方法需要递归，空间复杂度`O(logn)`；`bottom-up`的方法可以实现`O(1)`空间复杂度。
- 二维动态规划中，若给定的数据原本就是二维数组，可以考虑在原数组上操作dp，省一些空间
- 很骚的位操作：
  - 字母 与 空格 或运算可转换为小写， `"A" | " " == "a"`；
  - 字母 与 空格 与运算可转换为大写， `"A" & " " == "A"`；
  - 字母 与 空额 异或运算可大小写互换， `"A" ^ " " == "a"`；
  - 快速判断两数是否异号：`(a^b) < 0`，尽量不要直接用乘法，易出现溢出；
- 判断某整数`n`是否是2的幂，只需要看`n & (n - 1) == 0`即可。
- 看到要求两个整数 `x, y` 如何拼接得到结果更大时，应想到 `int -> str` ，然后比较 `x+y`和`y+x` 哪个更大即可，整数的比较，与字符串的比较，没有区别！见179题
- 如果问题关于大规模字符串的快速统计、排序、搜索等问题，迅速想到使用前缀树 `Trie Tree`，即字典树，能最大限度地减少无谓的字符串比较。核心思想是空间换时间，且是==动态查询==。因为字符串任务存在一个补全的问题，普通的哈希方法虽然也能高效搜索统计，但当字符串未输入完全时是无法哈希的，如存好的`apple`是无法用`app`查询到的。而哈希可以用bit数组，所以空间上比前缀树优化一些。
- `collections.defaultdict()`可以为字典只传`key`设置默认`value`，用于实现多叉树结构。

