小本本

完全二叉树一定有一个子树是满二叉树

动规问题中，对dp数组的定义，可以直接用字典而非[]，因为可以无限制的使用`dp[i]`而不需要提前定义长度

层序遍历中`while queue:`内的`len(queue)`只能用于内部迭代该层的遍历，不可用于判断深度。

单向BFS解决的问题，若终点位置明确，可以考虑用双向BFS，使用两个HashSet代替queue，两个方向遍历，随时交换，看是否有交集即可。

二分查找问题不要上来直接写，先搞定普通查索引的问题，再说明这种算法的局限性，是否需要进一步求左边界、右边界。

python字符串列表`strs = List[str]`小技巧：`max(strs)`, `min(strs)` 分别表示字典序最大和字典序最小的字符串。

数组内nSum问题等需要排重，记得用好`for`循环配合 `continue`功能，判断指针移动值未移动后直接再次循环即可；或者直接用`while`循环移动指针到下一个不同值处。

二叉树问题：两个节点都为空：`if not (left or right):`；两个节点至少一个为空：`if not (left and right):`；然后才可以通过`if left.val != right.val:`判断后续对称性等问题。

二叉树的递归操作内，只要想`node.left`/`node.right`/`node.val`之前都必须先判断`if not node`否则必报错。

python中的普通list数组可以使用拉链函数 `(zip(*matrix))` 进行转置。

判断二叉树叶子节点：1、`if not node.left and not node.right`；2、`if not  (node.left or node.right)`。

python 检测字符串s是否由字母和数字组成：`s.isalnum()`，卧槽这么重要的小技巧以前居然从来没见过？

众数问题、多数元素、最多出现问题莫忘了考虑使用**摩尔投票**法。

涉及到偶数个元素中找出现一次的某个元素，考虑使用 `^`运算，异或可交换，任何数异或自己都为零，零异或任何数都是任何数。

接上，若是在奇数各元素中找到出现一次的某个元素，同样使用异或 `^` 运算，只是多加几个中间变量就好，每次异或遍历时让其他的中间变量取非后求和运算即可，`once = ~twice & ~third & (num ^ once)`。

构建多为空数组时，不要小聪明用 `[[0] * n] * n`，会有浅拷贝问题，死都不知道怎么死的，老老实实`[[0 for _ in range(n)] for _ in range(n)]`。

十进制->二进制：`bin(42) ->'0b101010' `；二进制-> 十进制：`eval('0b101010') -> 42`。

双变量同时赋值更新时，如果不想使用临时变量，不要要写在一行内同时赋值。

